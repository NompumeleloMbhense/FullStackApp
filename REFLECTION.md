1. Explain how Copilot assisted in generating integration code, debugging issues, structuring JSON responses, and optimizing performance.
    Generating integration code
    -  API consumption: Generated HttpClient calls with proper headers, authentication, and error handling.
    Debugging issues 
    - Exception tracing: Analyzed stack traces and suggested fixes for common runtime errors.
    - Frontend glitches: Identified layout issues, broken animations, or navigation bugs in Blazor or Bootstrap.
structuring JSON responses
    - Serialization tips: Recommended System.Text.Json vs. Newtonsoft.Json based on use case.
    Optimizing performance
    - Database tuning: Suggested indexing strategies, stored procedures, and isolation level tweaks.

2. Highlight any challenges you encountered and how Copilot helped you overcome them.
    - Debugging Blazor routing, suggested layout components, and fixed broken links and parameters.
    - Recommend patterns like cascading parameters, local storage, or context providers.
    - Generated shared models and map backend responses to frontend types.
    - Database tuning: Suggested indexing strategies, stored procedures, and isolation level tweaks.

3. Discuss what you learned about using Copilot effectively in a full-stack development context.
    - Treating Copilot like a senior dev pairâ€”ask for code patterns, not just snippets.
    - Leaning on it for edge case brainstorming, especially in validation and exception handling.
    - Used it to validate architecture decisions, like layered design or service separation.






